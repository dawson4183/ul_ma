# Journal de Progrès
Run: f96077e7-75b6-4b7c-9874-9f2b029e6e6c
Tâche: Implémenter l'API d'authentification JWT
Débuté: 2026-02-12 11:27 AM

## Patterns de Codebase
- Architecture DDD avec domain/, application/, infrastructure/, api/
- Les entités du domaine utilisent des propriétés privées avec getters (ex: _user_id avec @property user_id)
- Validation métier dans le constructeur avec ValueError pour les erreurs
- Les méthodes métier modifient l'état directement (ex: verify(), deactivate())
- Les tests utilisent pytest avec des fixtures pour les données réutilisables
- mypy pour le typecheck avec --strict

---

## 2026-02-12 11:30 AM - US-001: Créer l'entité User dans le domaine
- Créé domain/user/user.py avec classe User
- Attributs: user_id, idul, email, password_hash, is_verified, is_active
- Validation: email avec '@', idul exactement 7 caractères, champs obligatoires non vides
- Méthodes métier: can_authenticate(), verify(), deactivate(), activate()
- Écrit 26 tests unitaires couvrant toutes les validations et méthodes métier
- Tous les tests passent (26 tests)
- Typecheck mypy passe sans erreur
- **Apprentissages:** Le pattern d'entité DDD suit le modèle de Listing: propriétés privées avec getters, validation dans __init__, méthodes métier pour changer l'état. can_authenticate() dépend de deux booléens (is_active ET is_verified).

Fichiers modifiés:
- domain/user/user.py (créé)
- tests/unit/domain/user/__init__.py (créé)
- tests/unit/domain/user/test_user.py (créé)

---

## 2026-02-12 03:21 PM - US-002: Créer l'entité Session dans le domaine
- Créé domain/auth/session.py avec classe Session
- Attributs: session_id, user_id, token, token_type, expires_at, used_at
- Types de token: 'auth', 'email_verification', 'password_reset'
- Validation: champs obligatoires non vides, token_type doit être valide, dates doivent être datetime
- Méthodes métier: is_expired(), is_used(), mark_as_used()
- is_expired() compare expires_at avec datetime.now()
- is_used() vérifie si used_at est non None
- mark_as_used() met à jour used_at avec datetime.now()
- Écrit 22 tests unitaires couvrant toutes les validations et méthodes métier
- Tous les tests passent (22 tests)
- Typecheck mypy passe sans erreur
- **Apprentissages:** La Session suit le même pattern DDD que User avec propriétés privées + getters. Les token types sont définis comme constantes de classe. is_expired() et is_used() sont des méthodes métier simples qui encapsulent la logique de validation.

Fichiers modifiés:
- domain/auth/session.py (créé)
- domain/auth/__init__.py (créé)
- tests/unit/domain/auth/__init__.py (créé)
- tests/unit/domain/auth/test_session.py (créé)

---

## 2026-02-12 09:02 AM - US-003: Créer le pattern Repository de base pour MySQL
- Créé infrastructure/persistence/mysql/base_repository.py
- Classe abstraite BaseMySQLRepository héritant de ABC
- Constructeur acceptant database_connection de type DatabaseConnection (injection de dépendance)
- Méthodes utilitaires: _execute_query(), _execute_many(), _fetch_one(), _fetch_all()
- Gestion automatique des curseurs via with statement (fermeture dans finally)
- Gestion des transactions: commit() automatique en cas de succès, rollback() en cas d'erreur
- Conversion des exceptions mysql.connector.Error en DatabaseException
- Méthodes abstraites: _get_table_name(), _map_to_entity() pour pattern Template Method
- Écrit 18 tests unitaires couvrant toutes les méthodes utilitaires et la gestion d'erreurs
- Tous les tests passent (47 tests total)
- **Apprentissages:** Le repository pattern permet de standardiser l'accès aux données. Les méthodes utilitaires gèrent automatiquement les curseurs et transactions. Les classes concrètes doivent implémenter _get_table_name() et _map_to_entity().

Fichiers modifiés:
- infrastructure/persistence/mysql/__init__.py (créé)
- infrastructure/persistence/mysql/base_repository.py (créé)
- tests/unit/infrastructure/persistence/__init__.py (créé)
- tests/unit/infrastructure/persistence/mysql/__init__.py (créé)
- tests/unit/infrastructure/persistence/mysql/test_base_repository.py (créé)

---

## 2026-02-12 04:55 PM - US-004: Créer l'interface UserRepository
- Créé domain/user/user_repository.py avec classe abstraite UserRepository
- UserRepository hérite de ABC (abstract base class)
- Méthodes abstraites: find_by_id(), find_by_email(), find_by_idul(), save(), exists_by_email()
- Retours typés: Optional[User] pour find_*, None pour save, bool pour exists_by_email
- Documentation complète avec docstrings en français
- Écrit 18 tests unitaires couvrant:
  - Les 5 méthodes abstraites doivent être implémentées
  - Une implémentation concrète complète fonctionne correctement
  - Cas limites: retour None quand utilisateur non trouvé
  - Insensibilité à la casse pour les emails
  - Mise à jour d'utilisateur existant
- Tous les tests passent (18 tests)
- Typecheck mypy passe sans erreur
- **Apprentissages:** Le pattern Repository suit exactement listing_repository.py: ABC avec @abstractmethod, méthodes retournant Optional[Entity] ou bool. L'interface définit le contrat, l'implémentation concrète (ex: MySQL) viendra après.

Fichiers modifiés:
- domain/user/user_repository.py (créé)
- tests/unit/domain/user/__init__.py (créé)
- tests/unit/domain/user/test_user_repository.py (créé)

---

## 2026-02-12 05:25 PM - US-005: Créer l'interface SessionRepository
- Créé domain/auth/session_repository.py avec classe abstraite SessionRepository
- Hérite de ABC avec 5 méthodes abstraites: find_by_token(), find_by_user_id(), save(), delete(), mark_as_used()
- Retours typés: Optional[Session] pour find_by_token(), List[Session] pour find_by_user_id(), None pour les autres
- Documentation complète avec docstrings en français suivant le pattern hexagonal (Port)
- Écrit 18 tests unitaires couvrant:
  - Les 5 méthodes sont bien abstraites (doivent être implémentées)
  - Implémentation concrète fonctionne correctement
  - Cas limites: retour None/Liste vide quand non trouvé
  - Mise à jour de session existante (changement de token)
- Tous les tests passent (18 tests)
- Typecheck mypy passe sans erreur (--strict --explicit-package-bases)
- **Apprentissages:** Le pattern est identique à UserRepository: ABC avec @abstractmethod, retours typés Optional[Entity] ou List[Entity]. Les méthodes métier comme mark_as_used() sont définies dans le repository pour la persistance, mais la logique métier reste dans l'entité Session.

Fichiers modifiés:
- domain/auth/session_repository.py (créé)
- tests/unit/domain/auth/test_session_repository.py (créé)

---

## 2026-02-12 06:28 PM - US-006: Créer les DTOs d'authentification
- Créé application/auth/dtos/ avec les 4 DTOs demandés
- RegisterRequestDto: email (str), password (str), idul (str)
- LoginRequestDto: email (str), password (str)
- AuthResponseDto: token (str), expires_at (str ISO), user_id (int), email (str) avec to_dict()
- UserResponseDto: user_id (int), idul (str), email (str), is_verified (bool), is_active (bool) avec to_dict()
- Utilise @dataclass comme dans listing/dtos/ avec imports typing pour mypy strict
- Écrit 11 tests unitaires couvrant création, valeurs variées, et méthodes to_dict()
- Tous les tests passent (11 tests)
- Typecheck mypy --strict --explicit-package-bases passe sans erreur
- **Apprentissages:** Les DTOs utilisent @dataclass avec type hints stricts (Dict[str, Any] pour to_dict()). Les DTOs Request n'ont pas besoin de to_dict() car ils sont créés à partir de requêtes API. Les DTOs Response ont to_dict() pour sérialisation JSON.

Fichiers modifiés:
- application/auth/__init__.py (créé)
- application/auth/dtos/__init__.py (créé)
- application/auth/dtos/register_request_dto.py (créé)
- application/auth/dtos/login_request_dto.py (créé)
- application/auth/dtos/auth_response_dto.py (créé)
- application/auth/dtos/user_response_dto.py (créé)
- tests/unit/application/auth/__init__.py (créé)
- tests/unit/application/auth/test_dtos.py (créé)

---

## 2026-02-12 07:30 PM - US-007: Créer le PasswordHasher service
- Créé infrastructure/security/password_hasher.py avec classe PasswordHasher
- Méthodes: hash_password(password) -> str, verify_password(password, hash) -> bool
- hash_password utilise bcrypt avec salt automatique (gensalt())
- verify_password compare le mot de passe avec le hash stocké
- Gestion des erreurs: ValueError pour paramètres vides/None, RuntimeError pour erreurs bcrypt
- verify_password retourne False pour un hash invalide (sans lever d'exception)
- Écrit 14 tests unitaires couvrant:
  - hash_password retourne un string bcrypt valide
  - Deux hash du même password sont différents (salt aléatoire)
  - verify_password retourne True pour match, False pour mismatch
  - Gestion des erreurs (paramètres vides/None, hash invalide)
  - Test d'intégration avec différents types de mots de passe
- Tous les tests passent (14 tests)
- Typecheck mypy --strict passe sans erreur
- **Apprentissages:** bcrypt.hashpw() génère automatiquement un salt aléatoire avec gensalt(). bcrypt.checkpw() retourne un booléen. Les erreurs de bcrypt doivent être capturées et converties en exceptions appropriées. C'est un service d'infrastructure (pas métier) qui encapsule la librairie de cryptographie.

Fichiers modifiés:
- infrastructure/security/password_hasher.py (créé)
- tests/unit/infrastructure/security/__init__.py (créé)
- tests/unit/infrastructure/security/test_password_hasher.py (créé)

---
## 2026-02-12 08:34 PM - US-008: Créer le JWT Service
- Créé infrastructure/security/jwt_service.py avec classe JwtService
- __init__(secret_key): initialise avec clé secrète depuis variables d'environnement
- generate_token(user_id, email): génère token JWT avec claims user_id, email, exp, iat, type
- Durée de validité: 24 heures configurée via timedelta(hours=24)
- validate_token(token): décode et valide le token, retourne payload
- Lève TokenInvalidException pour token invalide (format, signature)
- Lève SessionExpiredException pour token expiré (jwt.ExpiredSignatureError)
- Algorithme: HS256
- Écrit 23 tests unitaires couvrant:
  - Initialisation avec clé valide/vide/None
  - Génération token: format JWT valide, claims présents (user_id, email, exp, iat, type)
  - Validation token: payload retourné, erreurs pour token invalide/expiré
  - Gestion des erreurs: ValueError pour paramètres vides, exceptions métier pour tokens invalides
  - Test d'intégration: générer puis valider plusieurs tokens
- Tous les tests passent (23 tests)
- Typecheck mypy --strict passe sans erreur
- **Apprentissages:** PyJWT encode avec jwt.encode() et decode avec jwt.decode(). Les exceptions jwt.ExpiredSignatureError et jwt.InvalidTokenError doivent être capturées et converties en exceptions métier. Le token expire exactement 24h après la création grâce au claim 'exp'.

Fichiers modifiés:
- infrastructure/security/jwt_service.py (créé)
- tests/unit/infrastructure/security/test_jwt_service.py (créé)
- requirements.txt (ajout pyjwt==2.8.0)

---

## 2026-02-13 09:36 AM - US-009: Implémenter MySQLUserRepository
- Créé infrastructure/persistence/mysql/mysql_user_repository.py
- MySQLUserRepository hérite de BaseMySQLRepository et implémente UserRepository
- _get_table_name() retourne 'users'
- _map_to_entity() convertit dict en User avec gestion des booléens MySQL (0/1)
- find_by_id() utilise WHERE user_id = %s
- find_by_email() utilise WHERE email = %s (insensible à la casse)
- find_by_idul() utilise WHERE idul = %s
- save() INSERT si nouvel user, UPDATE si existant (vérifie existence d'abord)
- exists_by_email() utilise SELECT 1 LIMIT 1 pour vérifier l'existence
- Écrit 18 tests unitaires couvrant toutes les méthodes et cas limites
- Tous les tests passent (80 tests total pour user + mysql)
- **Apprentissages:** Le pattern Template Method de BaseMySQLRepository fonctionne bien: _get_table_name() et _map_to_entity() sont implémentés par les classes filles. Les requêtes utilisent des paramètres %s pour éviter les injections SQL. bool() convertit les entiers MySQL (0/1) en booléens Python.

Fichiers modifiés:
- infrastructure/persistence/mysql/mysql_user_repository.py (créé)
- tests/unit/infrastructure/persistence/mysql/test_mysql_user_repository.py (créé)

---
